# Отчет по практической работе №3 - Обеспечение быстродействия и надёжности распределёной системы

## Выполненные задачи

### 1. CI-процесс
#### Настройка автоматизированного процесса проверки кода

Реализован полноценный CI pipeline в GitHub Actions (`.github/workflows/ci-cd-mailforge.yml`), который запускается при:
- Push в ветку main
- Pull Request в ветку main

Pipeline состоит из следующих этапов:

1. **Линтинг и статический анализ (Job: lint)**
   - Black: проверка форматирования кода
   - Flake8: проверка стиля кода и поиск потенциальных ошибок
   - MyPy: статический анализ типов
   Проверка выполняется для всех Python-файлов в директориях:
   - server/app
   - services/*/app

2. **Тестирование (Job: test)**
   - Матричное тестирование для каждого сервиса:
     - server
     - auth
     - mailing
     - delivery
     - history
   - Для каждого сервиса:
     - Установка зависимостей из requirements.txt
     - Подключение shared-библиотеки
     - Запуск pytest с измерением покрытия кода
   - Тестирование frontend:
     - Установка Node.js
     - Запуск unit-тестов Vue.js приложения

3. **Сборка и публикация (Job: build)**
   - Запускается только после успешного прохождения тестов
   - Установка Docker Compose
   - Сборка Docker-образов всех сервисов
   - Авторизация в Docker Hub
   - Публикация собранных образов в Docker Hub registry

#### Особенности реализации
- Использование кэширования зависимостей для ускорения сборки
- Параллельное выполнение тестов для разных сервисов
- Автоматическая проверка кода при каждом изменении
- Интеграция с Docker Hub для хранения образов


### 2. Масштабирование компонентов системы
#### Реализация кэширования с помощью Redis

Для повышения производительности системы было реализовано кэширование данных пользователей в сервисе аутентификации с использованием Redis:

1. Добавлен Redis-сервер в инфраструктуру:
   - Настроен контейнер Redis в docker-compose
   - Настроена проверка здоровья (healthcheck)
   - Установлено соединение между auth-сервисом и Redis

2. Реализован механизм кэширования:
   - Создан Redis-клиент для работы с кэшем
   - Настроено кэширование данных пользователей с TTL 5 минут
   - Реализована проверка кэша перед обращением к базе данных

3. Стратегия обработки медленных запросов к кэшу:
   - Установлен timeout для операций с Redis
   - Настроено автоматическое устаревание кэша (TTL)
   - При медленной работе кэша система автоматически обращается к основной БД

### 3. Тесты
- Поддерживаются существующие unit-тесты
- Интеграционные тесты охватывают основную функциональность

## Технические детали реализации

### Redis кэширование
- Хранение данных пользователей в формате JSON
- Ключи формируются по шаблону "user:{id}"
- TTL кэша: 300 секунд (5 минут)
- Автоматическая инвалидация при изменении данных

## Заключение
Внедрение Redis-кэширования позволило:
- Снизить нагрузку на основную базу данных
- Ускорить получение часто запрашиваемых данных
- Обеспечить отказоустойчивость при проблемах с основной БД

### CI Pipeline Configuration
```yml
name: CI/CD Pipeline
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  lint:
    runs-on: ubuntu-latest 
    steps:
      - name: Run linting
        run: |
          black server/app services/*/app --check
          flake8 server/app services/*/app
          mypy server/app services/*/app
```

### Redis Integration
```yml
# Docker Compose сервис для Redis
redis:
  image: redis:latest
  ports:
    - "6379:6379"
  healthcheck:
    test: ["CMD", "redis-cli", "ping"]
    interval: 5s
    timeout: 5s
    retries: 5
```

### Caching Implementation
```python
@router.get("/{user_id}", response_model=UserDTO)
async def get_user(user_id: int, service: UserService = Depends(get_user_service)):
    # Сначала проверяем кэш
    cached_user = await RedisCache.get_user(user_id)
    if cached_user:
        return cached_user

    # Если нет в кэше, то запрашиваем из БД
    user = await service.get_by_id(user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    # Сохраняем в кэш
    await RedisCache.set_user(user_id, user.dict())
    return user
```

## Нереализованные задачи и обоснование

### 1. Централизованное логирование
- Внедрение GrayLog требует выделения значительных ресурсов для хранения и обработки логов
- На текущем этапе разработки достаточно локального логирования, так как система находится в стадии активной разработки

### 2. E2E тестирование
- Требует стабильной тестовой среды со всеми зависимостями (БД, Redis, RabbitMQ)
- На данном этапе приоритет отдан unit и интеграционным тестам как более критичным для текущей стадии разработки

### 3. CD процесс
- Отсутствует production-окружение и целевые серверы для развертывания
- Аренда серверов требует дополнительных финансовых затрат
- Docker Hub registry достаточен для текущих целей разработки

### 4. Дополнительные возможности масштабирования
- Текущая нагрузка на систему не требует балансировки и репликации
- Шардирование БД избыточно для текущего объема данных
- Redis-кэширование обеспечивает достаточную производительность на данном этапе

### 5. Семантические релизы
- Проект находится в активной разработке без необходимости частых релизов
- Текущая система версионирования через Git-теги удовлетворяет требованиям разработки


Весь программный код системы доступен в репозитории GitHub - [Ссылка!](https://github.com/KosmixGT/mailforge)
